1.(Seminar1)

    def reverse(self):
        prev = None
        current = self.head
        while current is not None:
            next_node = current.next
            current.next = prev
            prev = current
            current = next_node
        self.head = prev

Алгоритмичная сложность O(N)-алгоритм проходит по списку один раз направление его указателей

Затраты по памяти O(1) - используется переменная для того чтобы хранить указатель на предидущий эллемент

2.(Lab2)

Алгоритмическая сложность O(N^2)-колличество признаков на количество запросов

Затраты по памяти O(N^2)-хранится массив признаков, для всех объектов

3.(Seminar4)

    def invert_tree(self):
        self.root = self.__invert_tree(self.root)
    
    def __invert_tree(self, node):
        if node is None:
            return None
        # Меняем местами левого и правого потомков
        node.left, node.right = node.right, node.left
        # Рекурсивно инвертируем левого и правого потомков
        self.__invert_tree(node.left)
        self.__invert_tree(node.right)
        return node

Алгоритмическая сложность O(N)-алгоритм проходит по каждому узлу дерева один раз

Затраты по памяти O(N)-используется N уровней дерева для рекурсии

4-5.(Lab4-5)

Алгоритмическая сложность O(log(n))-для вставки, удаления, поиска понадобится не более log(n) шагов

Затраты по памяти O(N)-количество узлов в дереве

6.(Lab6)

Алгоритмическая сложность O(N^2)-алгоритм проходит по всем визитам и продолжительности

Затраты по памяти O(N)-хранится массив визитов


7.(Lab7)

Алгоритмическая сложность O(N^2)-алгоритм проходит по всем ребрам(E) графа для каждой вершины(V)

Затраты по памяти O(2N)-хранится массив расстояний(для каждой вершины O(v) памяти) и список ребер O(E)

8.(Lab8)

Алгоритмическая сложность O(N^3)-покрытие нулями и корректировка матрицы требуют проходить по всем эллементам матрицы

Затраты по памяти O(N^2)-хранится массивы нулей и основной массив